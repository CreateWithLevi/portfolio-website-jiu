---
import { getCollection } from "astro:content";
import BaseLayout from "@/layouts/BaseLayout.astro";
import Sidebar from "@/components/Sidebar.svelte";
import ProjectCard from "@/components/ProjectCard.svelte";

// Fetch all project collections
const [websites, branding, others] = await Promise.all([
  getCollection("websites"),
  getCollection("branding"),
  getCollection("others"),
]);

// Sort each category by order
const sortedWebsites = websites.sort(
  (a, b) => (a.data.order || 0) - (b.data.order || 0),
);
const sortedBranding = branding.sort(
  (a, b) => (a.data.order || 0) - (b.data.order || 0),
);
const sortedOthers = others.sort(
  (a, b) => (a.data.order || 0) - (b.data.order || 0),
);

// Combine all projects in order
const allProjects = [...sortedWebsites, ...sortedBranding, ...sortedOthers];

// Group projects by category
const projectsByCategory = {
  website: sortedWebsites,
  branding: sortedBranding,
  others: sortedOthers,
};
---

<BaseLayout>
  <div class="portfolio">
    <!-- Sidebar -->
    <Sidebar client:idle projects={allProjects} />

    <!-- Main Content -->
    <main class="content" id="main-content">
      <!-- Infinite Scroll Container -->
      <div class="infinite-scroll-container">
        <!-- Website Projects -->
        {
          projectsByCategory.website.length > 0 && (
            <div class="projects-grid">
              {projectsByCategory.website.map((project) => (
                <ProjectCard
                  client:visible
                  id={project.id}
                  title={project.data.title}
                  description={project.data.description}
                  media={project.data.media}
                  tags={project.data.tags}
                  url={project.data.url}
                  category="website"
                />
              ))}
            </div>
          )
        }

        <!-- Branding Projects -->
        {
          projectsByCategory.branding.length > 0 && (
            <div class="projects-grid">
              {projectsByCategory.branding.map((project) => (
                <ProjectCard
                  client:visible
                  id={project.id}
                  title={project.data.title}
                  description={project.data.description}
                  media={project.data.media}
                  tags={project.data.tags}
                  url={project.data.url}
                  category="branding"
                />
              ))}
            </div>
          )
        }

        <!-- Other Projects -->
        {
          projectsByCategory.others.length > 0 && (
            <div class="projects-grid">
              {projectsByCategory.others.map((project) => (
                <ProjectCard
                  client:visible
                  id={project.id}
                  title={project.data.title}
                  description={project.data.description}
                  media={project.data.media}
                  tags={project.data.tags}
                  url={project.data.url}
                  category="others"
                />
              ))}
            </div>
          )
        }
      </div>

      <!-- JIU Watermark (Desktop only) -->
      <!--<div class="watermark">JIU</div>-->
    </main>
  </div>
</BaseLayout>

<style>
  .portfolio {
    display: flex;
    min-height: 100vh;
    max-width: var(--max-width);
    margin: 0 auto;
  }

  .content {
    flex: 1;
    width: var(--content-width);
    padding: var(--spacing-36);
    position: relative;
    height: 100vh;
    overflow-y: auto;
    scroll-behavior: auto;
    scroll-snap-type: y proximity;
  }

  .infinite-scroll-container {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-100);
  }

  .projects-grid {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-100);
  }

  .projects-grid > :global(article) {
    scroll-snap-align: start;
    min-height: calc(100vh - 70px);
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  .watermark {
    position: fixed;
    bottom: 162px;
    left: var(--spacing-36);
    font-size: 105px;
    font-weight: var(--font-weight-bold);
    line-height: var(--line-height-normal);
    color: var(--white);
    white-space: nowrap;
    transform: translateY(100%);
    pointer-events: none;
    z-index: 10;
  }

  /* Mobile Styles */
  @media (max-width: 1023px) {
    .portfolio {
      flex-direction: column;
    }

    .content {
      width: 100%;
      padding: 0;
      height: auto;
      overflow-y: visible;
      scroll-snap-type: none;
    }

    .infinite-scroll-container {
      gap: var(--spacing-24);
    }

    .projects-grid {
      gap: var(--spacing-24);
    }

    .projects-grid > :global(article) {
      scroll-snap-align: none;
      min-height: auto;
      justify-content: flex-start;
    }

    .watermark {
      display: none;
    }
  }
</style>

<script>
  // Infinite scroll with Intersection Observer (Desktop only)
  document.addEventListener("DOMContentLoaded", () => {
    const content = document.getElementById("main-content") as HTMLElement;
    const container = document.querySelector(
      ".infinite-scroll-container",
    ) as HTMLElement;
    const sidebarLinks = document.querySelectorAll('.sidebar a[href^="#"]');

    if (!content || !container) return;

    // Check if desktop (min-width: 1024px)
    const isDesktop = () => window.matchMedia("(min-width: 1024px)").matches;

    // Only enable infinite scroll on desktop
    if (isDesktop()) {
      // Clone and append content for infinite scroll (3 copies for stability)
      const originalContent = container.cloneNode(true) as HTMLElement;
      const clone1 = originalContent.cloneNode(true) as HTMLElement;
      const clone2 = originalContent.cloneNode(true) as HTMLElement;

      // Remove IDs from clones to avoid conflicts
      const removeIds = (element: HTMLElement) => {
        element.querySelectorAll("[id]").forEach((el) => {
          (el as HTMLElement).removeAttribute("id");
        });
      };

      removeIds(clone1);
      removeIds(clone2);

      container.appendChild(clone1);
      container.appendChild(clone2);

      let isScrolling = false;
      let scrollTimeout: number;

      const handleScroll = () => {
        if (isScrolling) return;

        // Clear the timeout throughout the scroll
        clearTimeout(scrollTimeout);

        // Set a timeout to run after scrolling ends
        scrollTimeout = window.setTimeout(() => {
          const scrollTop = content.scrollTop;
          const scrollHeight = content.scrollHeight;
          const clientHeight = content.clientHeight;
          const oneThirdHeight = scrollHeight / 3;

          // If scrolled past 2/3, jump back to 1/3 (seamless loop)
          if (scrollTop > oneThirdHeight * 2 - clientHeight) {
            isScrolling = true;
            content.style.scrollBehavior = "auto";
            content.scrollTop = scrollTop - oneThirdHeight;
            setTimeout(() => {
              isScrolling = false;
            }, 100);
          }
          // If scrolled above 1/3, jump to 2/3 (backward loop)
          else if (scrollTop < oneThirdHeight / 3) {
            isScrolling = true;
            content.style.scrollBehavior = "auto";
            content.scrollTop = scrollTop + oneThirdHeight;
            setTimeout(() => {
              isScrolling = false;
            }, 100);
          }
        }, 150); // Wait 150ms after scroll stops
      };

      content.addEventListener("scroll", handleScroll, { passive: true });

      // Start at the middle section
      content.scrollTop = 1;
    }

    // Smooth scroll handling for anchor links (both desktop and mobile)
    sidebarLinks.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const targetId = (link as HTMLAnchorElement)
          .getAttribute("href")
          ?.slice(1);
        if (targetId) {
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            content.style.scrollBehavior = "smooth";
            targetElement.scrollIntoView({
              behavior: "smooth",
              block: "start",
            });
            // Reset scroll behavior after animation
            setTimeout(() => {
              content.style.scrollBehavior = "auto";
            }, 1000);
          }
        }
      });
    });
  });
</script>
